# Parsing Tips and Rules
* The expression as a whole is considered "Tier 0" - because of the tree-style parsing we are implementing, Tier 0 is the root node of the tree.
* Each set of parentheses creates a new lower tier, with an increased Tier number.
* If there are any logical conflicts in the same tier (different logical operators), a new tier is created internally based on the precedence rules.
* When tiers are referenced in this documentation, they are referred to as lists of LogicObjects. Each LogicObject is codified as `<sym> [subsidiaries]` where `<sym>` is the logical operator/mode for that LogicObject.

# Basic Parsing Procedure
The following procedure takes place after the user has entered a logical expression.
1. The expression is checked for syntax errors. If any are present, the user is re-prompted for an expression. See ` SYNTAX.md ` for full syntactic rules and reference.
2. The parser then parses out all terminal symbols and creates TERMINAL mode LogicObjects for them. They are then placed in a HashMap, with the terminal symbol itself as the key and the corresponding LogicObject as the value.
3. The parser then searches the top level of the expression for any logical operators. If it finds any, it creates a LogicObject corresponding to the operator. 
    * "Top level" here refers to "not enclosed with any parentheses." If there are parentheses present, the parsing becomes recursive.
    * The contents of the parentheses are treated as one LogicObject.
    * If there are multiple conflicting operators, refer to PRECEDENCE.md for full parser precedence rules. 
4. The LogicObjects are given references to the TERMINAL LogicObjects from our earlier HashMap as their subsidiaries. For example, the expression ` a & b ` would yield an AND LogicObject with subsidiaries of TERMINAL LogicObjects ` a ` and ` b `.
5. This parsing continues iteratively and recursively until the entire expression has been parsed into a kind of "tree" of LogicObjects. 
6. The truth table is then generated by iteratively changing the values of the TERMINAL LogicObjects to create every possible combination. At each change, the "root" LogicObject is passed to ` evaluate ` to achieve a result for the entire expression. 
